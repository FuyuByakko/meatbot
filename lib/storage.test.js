const Storage = require('./storage');

describe('Storage handler', () => {
  let storage;

  beforeEach(() => {
    storage = new Storage();
  })

  test('should create an instance of a loopQueue', () => {
    expect(storage).toBeDefined();
    expect(storage).toBeInstanceOf(Storage);
  });

  test('should instantiate with data param, set empty instance of Map', () => {
    expect(storage.data).toBeInstanceOf(Map);
    expect(storage.data.size).toEqual(0);
  });

	describe('ADD method', () => {
    test('should exist', () => {
      expect(storage.add).toBeDefined();
      expect(typeof storage.add).toBe('function');
		});
		
    test('should add the data to storage', () => {
			const testKey = 'testKey'
			const saveData = 'testData';
			storage.add(testKey, saveData)
      expect(storage.data.size).toEqual(1);
      expect(storage.data.has(testKey)).toBe(true);
      expect(storage.data.get(testKey)).toEqual(saveData);
    });
	
		test('should generate automatic key if given empty string (default - "AutoGeneratedKey")', () => {
			const defaultKey = 'AutoGeneratedKey';
			const testKey = ''
			const saveData = 'testData';
			storage.add(testKey, saveData)
			expect(storage.data.size).toEqual(1);
			expect(storage.data.has(defaultKey)).toBe(true);
			expect(storage.data.get(defaultKey)).toEqual(saveData);
    });
	
		test('should generate automatic key if given undefined (default - "AutoGeneratedKey")', () => {
			const defaultKey = 'AutoGeneratedKey';
			let testKey;
			const saveData = 'testData';
			storage.add(testKey, saveData)
			expect(storage.data.size).toEqual(1);
			expect(storage.data.has(defaultKey)).toBe(true);
			expect(storage.data.get(defaultKey)).toEqual(saveData);
		});
		
		test('should rewrite the data is same key is passed (overwrite not given)', () => {
			const testKey = 'testKey';
			const saveData = 'testData';
			const saveData2 = 'testData2';
			storage.add(testKey, saveData)
			storage.add(testKey, saveData2)
			expect(storage.data.size).toEqual(1);
			expect(storage.data.has(testKey)).toBe(true);
			expect(storage.data.get(testKey)).toEqual(saveData2);
    });
		
		test('should rewrite the data is same key is passed (overwrite set to true)', () => {
			const testKey = 'testKey';
			const saveData = 'testData';
			const saveData2 = 'testData2';
			const overwrite = true;
			storage.add(testKey, saveData, overwrite)
			storage.add(testKey, saveData2)
			expect(storage.data.size).toEqual(1);
			expect(storage.data.has(testKey)).toBe(true);
			expect(storage.data.get(testKey)).toEqual(saveData2);
    });
		
		test('should keep all data when same key is passed (overwrite set to false)', () => {
			const testKey = 'testKey';
			const saveData = 'testData';
			const saveData2 = 'testData2';
			const overwrite = false;
			storage.add(testKey, saveData, overwrite)
			storage.add(testKey, saveData2, overwrite)
			expect(storage.data.size).toEqual(2);
			let mapIter = storage.data.keys();
			let firstKey = mapIter.next().value;
			let secondKey = mapIter.next().value;
			expect(storage.data.has(firstKey)).toBe(true);
			expect(storage.data.has(secondKey)).toBe(true);

			let firstDataSet;
			let secondDataSet;
			if (testKey === firstKey) {
				firstDataSet = storage.data.get(firstKey);
				secondDataSet = storage.data.get(secondKey);
			} else {
				firstDataSet = storage.data.get(secondKey)
				secondDataSet = storage.data.get(firstKey)
			}
			expect(firstDataSet).toEqual(saveData);
			expect(secondDataSet).toEqual(saveData2);
    });
	});
	
	describe('SIZE method', () => {
    test('should exist', () => {
      expect(storage.size).toBeDefined();
      expect(typeof storage.size).toBe('function');
		});

    test('should be 0 upon creation', () => {
      expect(storage.size()).toEqual(0);
		});
		
    test('should be return number of saved items', () => {
			const testKey = 'testKey'
			const saveData = 'testData';
			const overwrite = false;
			storage.add(testKey, saveData, overwrite)
      expect(storage.size()).toEqual(1);
			storage.add(testKey, saveData, overwrite)
      expect(storage.size()).toEqual(2);
			storage.add(testKey, saveData, overwrite)
      expect(storage.size()).toEqual(3);
    });
	});

	describe('ENTRIES method', () => {
    test('should exist', () => {
      expect(storage.entries).toBeDefined();
      expect(typeof storage.entries).toBe('function');
		});

    test('should be return an iterator with next properties', () => {
			const iterator = storage.entries()
      expect(iterator.next).toBeDefined();
      expect(typeof iterator.next).toBe('function');
    });

		test('should return value of undefined for next() [key/value] pair on empty storage', () => {
			const iterator = storage.entries()
			const firstEntry = iterator.next();
      expect(firstEntry.value).not.toBeDefined();
      expect(firstEntry.done).toBe(true);
    });

		test('should return the added key.value pairs for each next call', () => {
			const testKey = 'testKey'
			const testKey2 = 'testKey2'
			const saveData = 'testData';
			const saveData2 = 'testData2';
			storage.add(testKey, saveData)
			storage.add(testKey2, saveData2)

			const iterator = storage.entries()
			const firstEntry = iterator.next()
			const secondEntry = iterator.next()
			const end = iterator.next()
      expect(firstEntry.value).toEqual([testKey, saveData]);
      expect(secondEntry.value).toEqual([testKey2, saveData2]);
      expect(end.done).toBe(true);
    });
	});

	describe('Eack method', () => {
    test('should exist', () => {
      expect(storage.each).toBeDefined();
      expect(typeof storage.each).toBe('function');
		});

    test('should call the given callback for every key - value pair', () => {
			const testKey = 'testKey'
			const testKey2 = 'testKey2'
			const saveData = 'testData';
			const saveData2 = 'testData2';
			storage.add(testKey, saveData)
			storage.add(testKey2, saveData2)
			let expectedArr = [
				`${testKey}-${saveData}`,
				`${testKey2}-${saveData2}`,
			];
			let resultArr = [];
			const populateArr = (key, value) => {
				resultArr.push(`${key}-${value}`);
			}

			storage.each(populateArr)
			
      expect(resultArr).toEqual(expectedArr);
    });
	});

	describe('toJSObject method', () => {
    test('should exist', () => {
      expect(storage.toJSObject).toBeDefined();
      expect(typeof storage.toJSObject).toBe('function');
		});

    test('should return an object (empty)', () => {
			const resultObj = storage.toJSObject()
			
      expect(typeof resultObj).toBe('object');
      expect(resultObj).toEqual({});
    });
    test('should return an object with set keys and Stringified values that were added', () => {
			const testKey = 'testKey'
			const testKey2 = 'testKey2'
			const saveData = 'testData';
			const saveData2 = 'testData2';
			storage.add(testKey, saveData)
			storage.add(testKey2, saveData2)
			
			const stringify = (entry) => JSON.stringify(entry);
			let expectedObj = {};
			expectedObj[testKey] = stringify(saveData);
			expectedObj[testKey2] = stringify(saveData2);
			
			const resultObj = storage.toJSObject()
			
      expect(resultObj).toEqual(expectedObj);
    });
	});
});